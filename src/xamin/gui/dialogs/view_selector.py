"""
Dialog to select which view to open
"""

import typing as t
import re
from types import SimpleNamespace
from pathlib import Path


from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import QDialog, QComboBox, QDialogButtonBox, QFormLayout
from PyQt6.QtGui import QStandardItemModel, QStandardItem

from ..view_models import BaseViewModel
from ...entry import Entry

__all__ = ("ViewSelector",)


class ViewSelector(QDialog):
    """Dialog box on file open to select entry type and view type"""

    #: The child widgets of the view selector
    widgets: SimpleNamespace

    #: The class cached dict of view models (values) organized by entry type (key)
    _view_models_by_entry_type: t.Dict[t.Type[Entry], QStandardItemModel]

    #: Base class attribute for the cached names (strings) of classes
    _class_names: t.Dict[str, t.Type]

    def __init__(self, *args, filepath: Path, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # Configure the attributes
        self.widgets = SimpleNamespace()
        self._class_names = dict()

        # Configure the dialog
        self.setWindowTitle("Open File")
        self.setWindowFlags(
            Qt.WindowType.Dialog
        )  # https://doc.qt.io/qt-6/qt.html#WindowType-enum

        # Setup the child widgets in a vbox layout
        layout = QFormLayout()

        combo1 = self.get_entry_types_combobox(filepath=filepath)
        layout.addRow("&File type:", combo1)

        combo2 = self.get_view_models_combobox()
        layout.addRow("&View type:", combo2)

        # Add the button box
        buttonbox = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.widgets.buttons = buttonbox

        buttonbox.accepted.connect(self.accept)
        buttonbox.rejected.connect(self.reject)
        layout.addWidget(buttonbox)

        self.setLayout(layout)

    def class_to_name(
        self, cls: t.Type, rstrips: t.Tuple[str] = ("Entry", "ViewModel")
    ) -> str:
        """Convert a CamelCase class name to a name string.

        Parameters
        ----------
        cls
            The class type to convert to a name string.
            If cls has a 'name' attribute, this will be used to get the name without
            applying rstrips.
        rstrips
            A tuple of strings that will be stripped from the end of the
            automatically-generated class name.

        Returns
        -------
        name
            The string for the class's name

        This method is designed to work with the name_to_class method.
        """
        if hasattr(cls, "name"):
            name = cls.name
        else:
            # e.g. "CodeEditorViewModel"
            name = cls.__name__

            # e.g. "CodeEditorViewModel" -> "CodeEditor"
            for rstrip in rstrips:
                name = re.sub(rstrip + r"$", "", name)

            # e.g. "CodeEditor" -> "Code Editor"
            name = " ".join(re.findall(r"[A-z][a-z0-9]+", name))

        self._class_names[name] = cls
        return name

    def name_to_class(self, name: str) -> t.Type | None:
        """Convert a pre-loaded name string back to its class.

        This method is designed to work with the class_to_name method.

        Parameters
        ----------
        name
            The string for the class's name

        Returns
        -------
        class
            The type corresponding to the name generated by the 'class_to_name' method.
            None if a class could not be found.
        """
        return self._class_names.get(name, None)

    def find_compatible_entry_types(self, filepath: Path) -> QStandardItemModel:
        """Find the entry types compatible with the given filepath.

        The first item is the best entry type guess.
        """
        hint = Entry.get_hint(path=filepath)
        compatible_classes = sorted(
            (
                cls
                for hierarchy, cls in Entry.subclasses()
                if cls.is_type(hint=hint, path=filepath)
            ),
            reverse=True,  # sort with the highest hierarchy number first
        )

        # Create and populate a data model for the combobox
        model = QStandardItemModel()
        for cls in compatible_classes:
            cls_name = self.class_to_name(cls)
            item = QStandardItem(cls_name)
            model.appendRow(item)

        return model

    def find_compatible_view_models(
        self, entry_type: t.Type[Entry]
    ) -> QStandardItemModel | None:
        """Provide a data model of ModelViews compatible with the given entry type"""
        # Generate the cached dict, if needed
        if not hasattr(ViewSelector, "_view_models_by_entry_type"):
            # Retrieve the BaseViewModel subclasses
            subclasses = BaseViewModel.subclasses()

            # Convert to a dict of entry_types (key) and compatible view models (values)
            d = dict()

            # Create a data model of compatible ViewModels for this entry type

            for subclass in subclasses:
                subclass_name = self.class_to_name(subclass)

                for entry_type in subclass.entry_compatibility:
                    model = d.setdefault(entry_type, QStandardItemModel())
                    item = QStandardItem(subclass_name)
                    model.appendRow(item)

            BaseViewModel._view_models_by_entry_type = d

        return (
            BaseViewModel._view_models_by_entry_type[entry_type]
            if entry_type in BaseViewModel._view_models_by_entry_type
            else None
        )

    def get_entry_types_combobox(self, filepath: Path) -> QComboBox:
        """Get, create and update the entry_types combobox"""
        # Create the widget, if needed
        if not hasattr(self.widgets, "entry_types_combobox"):
            self.widgets.entry_types_combobox = QComboBox(parent=self)

        # Get the data model
        model = self.find_compatible_entry_types(filepath=filepath)

        # Update the widget
        combo = self.widgets.entry_types_combobox
        combo.setModel(model)

        return combo

    def get_view_models_combobox(self) -> QComboBox:
        """Get, create and update the ViewModels combobox"""
        # Create the widget, if needed
        if not hasattr(self.widgets, "view_models_combobox"):
            self.widgets.view_models_combobox = QComboBox(parent=self)

        # Find the selected entry_type
        entry_type = self.selected_entry_type()

        # Get the data model
        model = self.find_compatible_view_models(entry_type=entry_type)

        # Update the widget
        combo = self.widgets.view_models_combobox
        combo.setModel(model)

        return combo

    def selected_entry_type(self) -> t.Type[Entry] | None:
        """Retrieve the currently selected entry type form the entry_types combobox"""
        if not hasattr(self.widgets, "entry_types_combobox"):
            return None

        combo: QComboBox = self.widgets.entry_types_combobox
        cls_name = combo.currentText()
        return self.name_to_class(cls_name)

    def selected_view_model_type(self) -> BaseViewModel | None:
        """Retrieve the currently selected ViewModel type from the view_models
        combobox."""
        if not hasattr(self.widgets, "view_models_combobox"):
            return None

        combo: QComboBox = self.widgets.view_models_combobox
        cls_name = combo.currentText()
        return self.name_to_class(cls_name)
