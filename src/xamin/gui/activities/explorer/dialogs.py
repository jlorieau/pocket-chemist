"""
Dialog windows for the File Explorer sidebar
"""

"""
Dialog to select which view to open
"""

import typing as t
import re
from pathlib import Path


from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import QDialog, QComboBox, QDialogButtonBox, QFormLayout, QWidget
from PyQt6.QtGui import QStandardItemModel, QStandardItem

from xamin.entry import Entry
from ..base import BaseActivity

__all__ = ("ActivitySelector",)

#: The types that can be selected
SelectorTypes = type[Entry] | type[BaseActivity]


class ActivitySelectorWidgets:
    """The collection of widgets for the ActivitySelector class"""

    __slots__ = ("buttons", "entry_types_combobox", "activity_types_combobox")

    #: The collection of buttons for the dialog window
    buttons: QDialogButtonBox

    #: The combobox for selecting the Entry type
    entry_types_combobox: QComboBox

    #: The combobox for selecting the Activity type
    activity_types_combobox: QComboBox


class ActivitySelector(QDialog):
    """Dialog box on file open to select entry and activity types"""

    #: The child widgets of the view selector
    widgets: ActivitySelectorWidgets

    #: Base class attribute for the cached names (strings) of classes
    _class_names: t.Dict[str, SelectorTypes]

    def __init__(
        self,
        filepath: Path,
        parent: QWidget | None = None,
        flags: Qt.WindowType = Qt.WindowType.Window,
    ):
        super().__init__(parent=parent, flags=flags)

        # Configure the attributes
        self.widgets = ActivitySelectorWidgets()
        self._class_names = dict()

        # Configure the dialog
        # https://doc.qt.io/qt-6/qt.html#WindowType-enum
        self.setWindowTitle("Open File")
        self.setWindowFlags(Qt.WindowType.Dialog)

        # Setup the child widgets in a vbox layout
        layout = QFormLayout()

        combo1 = self.get_entry_types_combobox(filepath=filepath)
        layout.addRow("&Format:", combo1)

        combo2 = self.get_activity_types_combobox()
        layout.addRow("&Activity:", combo2)

        # Add the button box
        buttonbox = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Cancel | QDialogButtonBox.StandardButton.Ok
        )
        self.widgets.buttons = buttonbox

        # Configure the button box default buttons to make 'ok' default
        ok_button = buttonbox.button(QDialogButtonBox.StandardButton.Ok)
        if ok_button is not None:
            ok_button.setAutoDefault(True)
            ok_button.setDefault(True)

        cancel_button = buttonbox.button(QDialogButtonBox.StandardButton.Cancel)
        if cancel_button is not None:
            cancel_button.setAutoDefault(False)
            cancel_button.setDefault(False)

        # Connect buttonbox signals
        buttonbox.accepted.connect(self.accept)
        buttonbox.rejected.connect(self.reject)
        layout.addWidget(buttonbox)

        # Appy the layout for this dialog's widget
        self.setLayout(layout)

    def class_to_name(
        self, cls: SelectorTypes, rstrips: tuple[str, ...] = ("Entry", "Activity")
    ) -> str:
        """Convert a CamelCase class name to a name string.

        Parameters
        ----------
        cls
            The class type to automatically convert to a name string.
            If cls has a 'name' attribute, this will be used instead to get the name
            without applying rstrips.
        rstrips
            A tuple of strings that will be stripped from the end of the
            automatically-generated class name.

        Returns
        -------
        name
            The string for the class's name

        This method is designed to in concert with the name_to_class method.
        """
        if cls is not None and hasattr(cls, "name"):
            name = cls.name
        else:
            # e.g. "CodeEditorActivity"
            name = cls.__name__

            # e.g. "CodeEditorActivity" -> "CodeEditor"
            # e.g. "TextEntry" -> "Text"
            for rstrip in rstrips:
                name = re.sub(rstrip + r"$", "", name)

            # e.g. "CodeEditor" -> "Code Editor"
            name = " ".join(re.findall(r"[A-z][a-z0-9]+", name))

        self._class_names[name] = cls
        return name

    def name_to_class(self, name: str) -> SelectorTypes:
        """Convert a pre-loaded name string back to its class.

        This method is designed to work in concert with the class_to_name method.

        Parameters
        ----------
        name
            The string for the class's name

        Returns
        -------
        class
            The type corresponding to the name generated by the 'class_to_name' method.
        """
        return self._class_names[name]

    def find_entry_types(self, filepath: Path) -> QStandardItemModel:
        """Provide the model for entry types compatible with the given filepath.

        The first item is the best entry type guess.
        """
        hint = Entry.get_hint(path=filepath)

        # Find the compabitible score, and place classes with a higher score earlier
        # in the list (reverse order)
        compatible_classes = [
            cls
            for cls in Entry.subclasses()[::-1]
            if cls.is_type(path=filepath, hint=hint)
        ]

        # Create and populate a data model for the combobox
        model = QStandardItemModel()
        for cls in compatible_classes:
            cls_name = self.class_to_name(cls)
            item = QStandardItem(cls_name)
            model.appendRow(item)

        return model

    def find_activity_types(self, entry_type: t.Type[Entry]) -> QStandardItemModel:
        """Provide the model of ModelViews compatible with the given entry type"""
        # Find the compatible activities for the given entry_type
        activity_types = BaseActivity.compatibilities(entry_type=entry_type)

        # Convert the entry_types to a model for the combobox
        model = QStandardItemModel()

        for activity_type in activity_types:
            name = self.class_to_name(activity_type)
            item = QStandardItem(name)
            model.appendRow(item)

        return model

    def get_entry_types_combobox(self, filepath: Path) -> QComboBox:
        """Get, create and update the entry_types combobox"""
        # Create the widget, if needed
        if not hasattr(self.widgets, "entry_types_combobox"):
            self.widgets.entry_types_combobox = QComboBox(parent=self)

        # Get the data model
        model = self.find_entry_types(filepath=filepath)

        # Update the widget
        combo = self.widgets.entry_types_combobox
        combo.setModel(model)

        return combo

    def get_activity_types_combobox(self) -> QComboBox:
        """Get, create and update the ViewModels combobox"""
        # Create the widget, if needed
        if not hasattr(self.widgets, "activity_types_combobox"):
            self.widgets.activity_types_combobox = QComboBox(parent=self)

        # Create the combobox
        combo = self.widgets.activity_types_combobox

        # Find the selected entry_type
        entry_type = self.selected_entry_type()

        # Get the data model
        if entry_type is not None:
            model = self.find_activity_types(entry_type=entry_type)
            combo.setModel(model)  # Update the widget

        return combo

    def selected_entry_type(self) -> type[Entry] | None:
        """Retrieve the currently selected entry type form the entry_types combobox"""
        if not hasattr(self.widgets, "entry_types_combobox"):
            return None

        combo = self.widgets.entry_types_combobox
        cls_name = combo.currentText()
        cls = self.name_to_class(cls_name)

        assert issubclass(cls, Entry)
        return cls

    def selected_activity_type(self) -> type[BaseActivity] | None:
        """Retrieve the currently selected Activity type from the view_models
        combobox."""
        if not hasattr(self.widgets, "activity_types_combobox"):
            return None

        combo = self.widgets.activity_types_combobox
        cls_name = combo.currentText()
        cls = self.name_to_class(cls_name)

        assert issubclass(cls, BaseActivity)
        return cls
